// Definimos los pines para cada color del LED RGB
const int redPin = 10;
const int greenPin = 9;
const int bluePin = 8;

#define dirPin 2
#define stepPin 3
#define aceptar 12 // Pin del pulsador para girar en sentido de las agujas del reloj
#define adelante 4
#define atras 11
#define stepsPerRevolution 212
#include <Wire.h>
#include <LiquidCrystal_I2C.h>

LiquidCrystal_I2C lcd(0x27, 16, 2); 
int distancia = 0; // Declaración de variable global
const int potPin = A1;
int distanciaObjetivo = 0; // Variable para la distancia objetivo
int lastDistancia = -1; // Último valor de distancia
int lastDistanciaObjetivo = -1; // Último valor de distancia objetivo

void setup() {
  lcd.init();
  lcd.backlight();
  Serial.begin(9600);

  // Declara los pines como salida o entrada:
  pinMode(stepPin, OUTPUT);
  pinMode(dirPin, OUTPUT);
  pinMode(aceptar, INPUT_PULLUP); // Pulsador con resistencia pull-up interna
  // colores
  pinMode(redPin, OUTPUT);
  pinMode(greenPin, OUTPUT);
  pinMode(bluePin, OUTPUT);

  // otros led
  pinMode(adelante, INPUT_PULLUP); // Establece el pin 11 como entrada con resistencia interna activada
  pinMode(atras, INPUT_PULLUP);

  pinMode(13, OUTPUT); // Configura el pin 13 como salida
  // digitalWrite(13, HIGH);
  pinMode(7, OUTPUT);
  pinMode(6, OUTPUT);
}

void loop() {
  setColor(0, 0, 255); // boton adelante
  digitalWrite(13, HIGH); // boton atras
  digitalWrite(6, HIGH);
  
  int estado_adelante = digitalRead(adelante);
  int estado_atras = digitalRead(atras);
  int estado_aceptar = digitalRead(aceptar);

  if (estado_adelante == LOW) { // Verifica si el botón conectado al pin 11 está presionado
    Serial.println("Boton en pin 11 presionado");
    digitalWrite(dirPin, LOW);
    distancia += 1;
    setColor(255, 0, 0); // Rojo
    moveMotor();
  }

  if (estado_atras == LOW) { // Verifica si el botón conectado al pin 12 está presionado
    Serial.println("Boton en pin 12 presionado");
    if (distancia > 0) {
      digitalWrite(dirPin, HIGH);
      distancia -= 1;
      digitalWrite(13, LOW); //LUZ AZUL
      digitalWrite(7, HIGH); // LUZ ROJA
      moveMotor();
    } else {
      lcd.setCursor(0, 0);
      lcd.print("Invalido:");
    }
  }
  digitalWrite(7, LOW);

  // Lee el valor del potenciometro
  int potValue = analogRead(potPin);

  // Mapear el valor del potenciómetro (0-1023) a la distancia (0-37 cm)
  distanciaObjetivo = map(potValue, 0, 1023, 0, 37);

  if (estado_aceptar == LOW) {
    Serial.println("Botón aceptar presionado");
    while (distancia != distanciaObjetivo) {
      Serial.print("Distancia actual: ");
      Serial.println(distancia);
      Serial.print("Distancia objetivo: ");
      Serial.println(distanciaObjetivo);
      if (distanciaObjetivo > distancia) {
        digitalWrite(dirPin, LOW);
        moveMotor();
        distancia += 1;
      } else {
        digitalWrite(dirPin, HIGH);
        moveMotor();
        distancia -= 1;
      }
      actualizarLCD();
    }
  }

  setColor(0, 0, 0); // Apaga el LED RGB
  actualizarLCD(); // Actualiza la LCD después de cada cambio de distancia y potenciómetro
}

void moveMotor() {
  // Haz girar el motor 5 revoluciones rápidamente:
  for (int i = 0; i < 5 * stepsPerRevolution; i++) {
    // Estas cuatro líneas resultan en 1 paso:
    digitalWrite(stepPin, HIGH);
    delayMicroseconds(900);
    digitalWrite(stepPin, LOW);
    delayMicroseconds(900);
  }
}

// Función para establecer el color del LED RGB
void setColor(int red, int green, int blue) {
  analogWrite(redPin, red);
  analogWrite(greenPin, green);
  analogWrite(bluePin, blue);
}

// Función para actualizar el valor de la distancia en la LCD
void actualizarLCD() {
  if (distancia != lastDistancia || distanciaObjetivo != lastDistanciaObjetivo) {
    char buffer[16];
    lcd.setCursor(0, 0);
    lcd.print("Actual:");
    lcd.setCursor(8, 0);
    sprintf(buffer, "%02d cm", distancia);
    lcd.print(buffer);
  
    lcd.setCursor(0, 1);
    lcd.print("Obj:");
    lcd.setCursor(8, 1);
    sprintf(buffer, "%02d cm", distanciaObjetivo);
    lcd.print(buffer);

    // Actualiza los últimos valores registrados
    lastDistancia = distancia;
    lastDistanciaObjetivo = distanciaObjetivo;
  }
}
